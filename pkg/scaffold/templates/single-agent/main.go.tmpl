package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"time"

	agk "github.com/agenticgokit/agenticgokit/v1beta"
)

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	// Get service version from environment or use default
	serviceVersion := os.Getenv("SERVICE_VERSION")
	if serviceVersion == "" {
		serviceVersion = "0.1.0"
	}

	// Create an agent with tools and memory
	// Observability is automatically configured via the builder pattern:
	// - If AGK_TRACE=true, tracing is automatically enabled
	// - Default exporter is file (creates traces-{runID}.jsonl)
	// - Can be customized via env vars: AGK_TRACE_EXPORTER, AGK_TRACE_ENDPOINT, AGK_TRACE_SAMPLE
	// Usage: AGK_TRACE=true go run main.go
	agent, err := agk.NewBuilder("{{.ProjectName}}").

		WithObservability("{{.ProjectName}}", serviceVersion).
		WithConfig(&agk.Config{
			Name:         "{{.ProjectName}}",
			SystemPrompt: "You are a helpful research assistant. Provide detailed, well-structured answers with examples when appropriate.",
			Timeout:      30 * time.Second,
			LLM: agk.LLMConfig{
				Provider:    "{{.LLMProvider}}",
				Model:       "{{.LLMModel}}",
				Temperature: 0.7,
				MaxTokens:   2000,
			},
		}).
		Build()
	if err != nil {
		log.Fatalf("Failed to create agent: %v", err)
	}
	defer agent.Cleanup(ctx)

	// Example with tools would be added here
	// For now, basic conversation with streaming

	userMessage := "Help me understand AgenticGoKit's architecture"

	fmt.Printf("User: %s\n\n", userMessage)
	fmt.Println("Assistant:")

	// Use streaming for real-time response and better timeout handling
	stream, err := agent.RunStream(ctx, userMessage)
	if err != nil {
		log.Fatalf("Failed to start streaming: %v", err)
	}

	printStreamingResponse(stream)
}

// printStreamingResponse prints the streaming response as tokens arrive
func printStreamingResponse(stream agk.Stream) {
	for chunk := range stream.Chunks() {
		if chunk.Error != nil {
			fmt.Printf("\n❌ Error: %v\n", chunk.Error)
			break
		}

		switch chunk.Type {
		case agk.ChunkTypeDelta:
			fmt.Print(chunk.Delta)
		case agk.ChunkTypeDone:
			fmt.Println("\n\n✅ Completed")
		}
	}
}
