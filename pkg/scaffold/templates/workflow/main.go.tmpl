package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"time"

	agk "github.com/agenticgokit/agenticgokit/v1beta"
	_ "github.com/agenticgokit/agenticgokit/plugins/llm/{{if .LLMProvider}}{{.LLMProvider}}{{else}}openai{{end}}"
)

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 300*time.Second)
	defer cancel()

	fmt.Println("ğŸš€ Creating {{.ProjectName}} Workflow...")
	fmt.Println("=====================================")

	// Create a sequential workflow with multiple agents
	// Tracing is handled at the workflow level (set AGK_TRACE=true)
	workflow, err := agk.NewSequentialWorkflow(&agk.WorkflowConfig{
		Mode:    agk.Sequential,
		Timeout: 180 * time.Second,
	})
	if err != nil {
		log.Fatalf("Failed to create workflow: %v", err)
	}

	// Shared base configuration
	baseLLM := agk.LLMConfig{
		Provider:  "{{.LLMProvider}}",
		Model:     "{{.LLMModel}}",
		APIKey:    os.Getenv("{{.APIKeyEnv}}"),
		MaxTokens: 2000,
	}

	// Helper to create agents cleanly
	createAgent := func(name, prompt string, temp float64) agk.Agent {
		cfg := baseLLM
		cfg.Temperature = float32(temp) // Convert float64 to float32

		// Create agent with specific config
		agent, err := agk.NewBuilder(name).
			WithConfig(&agk.Config{
				Name:         name,
				SystemPrompt: prompt,
				Timeout:      60 * time.Second,
				LLM:          cfg,
			}).Build()
		if err != nil {
			log.Fatalf("Failed to create %s: %v", name, err)
		}
		return agent
	}

	// Create agents
	researcher := createAgent("researcher",
		"You are a research assistant. When given a topic, provide detailed, factual information about it. Include key concepts, important details, and relevant context.",
		0.7)

	summarizer := createAgent("summarizer",
		"You are a summarization expert. Take the provided content and create a clear, concise summary that captures the key points. Use bullet points for clarity.",
		0.5)

	formatter := createAgent("formatter",
		"You are a content formatter. Take the provided summary and format it as a professional report with sections, headers, and clear structure.",
		0.3)

	// Add steps to the workflow
	// Step 1: Research - gather information
	if err := workflow.AddStep(agk.WorkflowStep{
		Name:  "research",
		Agent: researcher,
	}); err != nil {
		log.Fatalf("Failed to add research step: %v", err)
	}

	// Step 2: Summarize - condense the research
	if err := workflow.AddStep(agk.WorkflowStep{
		Name:  "summarize",
		Agent: summarizer,
	}); err != nil {
		log.Fatalf("Failed to add summarize step: %v", err)
	}

	// Step 3: Format - create final output
	if err := workflow.AddStep(agk.WorkflowStep{
		Name:  "format",
		Agent: formatter,
	}); err != nil {
		log.Fatalf("Failed to add format step: %v", err)
	}

	// Initialize the workflow
	if err := workflow.Initialize(ctx); err != nil {
		log.Fatalf("Failed to initialize workflow: %v", err)
	}
	defer workflow.Shutdown(ctx)

	// Run the workflow with streaming
	topic := "artificial intelligence in healthcare"
	fmt.Printf("\nğŸ“‹ Topic: %s\n\n", topic)

	// Show observability hint
	fmt.Println("ğŸ’¡ Tip: Enable tracing with: AGK_TRACE=true AGK_TRACE_EXPORTER=file")
	fmt.Println("ğŸ“¡ Streaming workflow execution:")
	fmt.Println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")

	stream, err := workflow.RunStream(ctx, topic)
	if err != nil {
		log.Fatalf("Failed to start workflow: %v", err)
	}

	// Track progress through steps
	for chunk := range stream.Chunks() {
		if chunk.Error != nil {
			fmt.Printf("\nâŒ Error: %v\n", chunk.Error)
			break
		}

		switch chunk.Type {
		case agk.ChunkTypeAgentStart:
			if stepName, ok := chunk.Metadata["step_name"].(string); ok {
				fmt.Printf("\n\nğŸ”¹ [Step: %s]\n", stepName)
				fmt.Println("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€")
			}
		case agk.ChunkTypeDelta:
			fmt.Print(chunk.Delta)
		case agk.ChunkTypeAgentComplete:
			if stepName, ok := chunk.Metadata["step_name"].(string); ok {
				fmt.Printf("\nâœ… Step '%s' completed\n", stepName)
			}
		case agk.ChunkTypeDone:
			fmt.Println("\n\n=====================================")
			fmt.Println("ğŸ‰ WORKFLOW COMPLETED")
			fmt.Println("=====================================")
		}
	}

	// Get final result
	result, err := stream.Wait()
	if err != nil {
		log.Fatalf("Workflow failed: %v", err)
	}

	fmt.Printf("\nğŸ“Š Duration: %v | Success: %v\n", result.Duration, result.Success)
}
